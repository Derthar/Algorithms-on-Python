# Максимальная сложность O(n*m), где n-длина строки в которой ищем, а m-длина подстроки, которую ищем

"""
Вариант 1 : Прямой поиск. Сопоставляем 2 строки и посимвольно сравниваем, при первом же несовпадении смещаем
подстроку - образец на 1 символ вправо и повторяем
"""

"""
Вариант 2 : Прямой поиск улучшенный. Сопоставляем 2 строки и посимвольно сравниваем, при несовпадении не в 1 символе,
смещаем подстроку на длину подстроки. Затем при несовпадении первого символа смещаем на 1 символ
(Но в данной случае есть риск пропуска образца, если в нем присутствуют повторяющиеся символы)
(В этом случае необходимо смещать образец относительно строки на повторяющийся префикс)
"""

"""
    Этапы алгоритма КМП:
1. Поиск и формирование массива суффиксов (для смещения)
2. Поиск образа в строке

    Массив префиксов : 
1. 1-й элемент всегда равен нулю
2. Последующие элементы - хранят длины совпадающий префиксов и суффиксов

    Этап 1. Алгоритм формирования массива n: 
1. Имеем строку-образец А. Запускаем 2 счетчика i(сразу принимает значение 1) и j(сразу принимает значение 0)
Если А[i] != A[j], то: если j == 0, то: n[i] = 0, затем i+=1 и повторяем.
            Иначе (j > 0): j = n[j-1]
    В случае совпадения (А[i] == A[j]) : n[i] = j+1, затем i+=1 и j+=1
Сложность равняется О(m), где m = Длина подстроки

    Этап 2. Поиск подстроки в строке
1. Совмещаем 2 строки и посимвольно сравниваем. При несовпадении в символе i, смещаем указатель подстроки-образца на А[n[i-1]]
Максимальная сложность равно О(n+m)
"""

# Этап 1
A = 'лилила'
lena = len(A)
j = 0
i = 1
n = [0] * lena
print(n)
while i < lena:
    if A[i] != A[j]:
        if j == 0:
            n[i] = 0
            i += 1
        else:
            j = n[j - 1]
    else:
        n[i] = j + 1
        i += 1
        j += 1

print(n)


# Этап 2
i = 0
j = 0
P = 'лилило лилилила'
s = 0
while i < lena:
    if lena>len(P):
        print('Образ больше строки, условие невозможно')
        break
    s += 1 # steps counter
    if A[i] == P[j]:
        i += 1
        j += 1
        if i == lena:
            print(f'Образ найден, он начинается с {j - lena} символа')
            break
        elif j >= len(P):
            print('Образа нет')
            break
    else:
        if i == 0:
            j += 1
            if j >= len(P):
                print('Образа нет')
                break
        else:
            i = n[i-1]
c = j - lena
print(f'first index is {c}')
print(P[c:c + lena:])
print(f'steps = {s}')
