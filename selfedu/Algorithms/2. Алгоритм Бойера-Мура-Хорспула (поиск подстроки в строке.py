"""
Ищет подстроку в строке(без повторяющихся суффиксов) быстрее чем прямой поиск

    Этапы:
1. Формирование таблицы смещений:
- Смещения формируются для каждого символа в строка-образе относительно ее конца
    Предпоследний - 1, предпредпоследний - 2 и т.д. Но если символ повторяется, то для них смещение совпадает.
Затем если последний символ не встречался в строке - то его смещение = длина строки, а если встречался - смещение
    равно смещению такого же символа в строке
Затем добавляем еще одно значение равно длине строки - которое отвечает за все остальноые символы
Затем удаляем все повторы

2. Совмещаем 2 строки и начинаем посимвольное сравнение с конца образа. Если не совпадает последний символ образа, то
берем несовпадающий символ исходной строки ищем для него смещение и смещаем образ.
Если несовпадение в НЕ последнем символе образа, то берем несовпадающий символ из образа и ищем для него смещение

Обьем вычислений - О(n*m)-худший вариант  O(n/m)-лучший вариант
"""

# T = 'большие метеоданные'
# t = 'данные'

T = 'лилило лилилила'
t = 'лилила'

# Этап 1
S = set()
M = len(t)
d = {}

# Пробегаемся по образу в обратном порядке, начиная с элемента -2 и вычисляем смещения и добавляем в уникальный список
for i in range(M-2, -1, -1):
    if t[i] not in S:
        d[t[i]] = M-i-1
        S.add(t[i])

# Если последий элемент не повторяется то его смещение равно длине образа
if t[M-1] not in S:
    d[t[M-1]] = M

# Добавляем значений для остальных символов, равное длине образа
d['*'] = M

print(d)
print(S)

# Этап 2
i = M-1
j = M-1
s = 0
while i > 0:
    if M > len(T):
        print('Образ больше строки, условие невозможно')
        break
    s += 1
    if t[i] == T[j]:
        i -= 1
        j -= 1
    else:
        if i == M-1:
            if T[j] not in d:
                j += d['*']
            else:
                j += d[T[j]]
        else:
            j += (M-1-i)+d[t[i]]
            i = M-1

print(i)
print(j)
print(f'steps = {s}')
